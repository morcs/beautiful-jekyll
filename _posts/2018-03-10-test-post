---
layout: post
title: Why functional programming?
tags: [functional-programming]
bigimg: /img/why-fp.gif
---


In the [previous post](2017-12-02-why-functional-programming/) I picked out what I think is one of the most compelling answers to the question ‚ÄúWhy Functional Programming?‚Äù. That is, in order to avoid dealing with exceptions and nulls.

I gave an example of using functional techniques in C# to do this, without really explaining what makes it functional programming.

To go further I think it‚Äôs worth going a bit deeper into what avoiding exceptions and nulls really means, in functional programming terms.

## Partial Functions

I used this snippet of C# code to talk about a problem:

```C#
decimal totalSalary = companies.Single(x => x.ID == companyID)
                               .Employees
                               .Sum(x => x.Salary);
```

The problem is the Single method. Its [signature](https://msdn.microsoft.com/en-us/library/bb535118%28v=vs.110%29.aspx) here essentially boils down to:

```C#
public static Customer Single(...)
```

`Single`‚Äôs signature tells us it returns a Customer, but it‚Äôs lying!

In reality, `Single` *sometimes* returns a Customer. If the input causes no match, it throws an exception. In the strict language of mathematics it‚Äôs a [partial function](https://en.wikipedia.org/wiki/Partial_function), it doesn‚Äôt return a value for every possible input. We‚Äôre expected to try and remember that each time we use it. Wouldn‚Äôt it be better to get the compiler to pick that up instead?

## Total Functions?

![Total Functions](/img/total-functions-2.jpeg)

Maybe (pun-intended) we can avoid this trap by using something that does return a value for every possible input, thus making it a [total function](https://en.wikipedia.org/wiki/Partial_function#Total_function) (a ‚Äúfunction‚Äù, to give its proper mathematical name üòú)

*I‚Äôll choose to ignore that the companies collection could be null here, its just the same problem showing up somewhere else.*

Well `SingleOrDefault` seems to do the trick. With `SingleOrDefault` every input should return an output, which will either be a Customer or `null`.

So what‚Äôs different about the [signature](https://msdn.microsoft.com/en-us/library/bb549274%28v=vs.110%29.aspx) of `SingleOrDefault`?
```C#
public static Customer Single(...)
public static Customer SingleOrDefault(...)
```

The difference is‚Ä¶there isn‚Äôt one! Another liar, but this one‚Äôs worse! At least when `Single` actually returns something, that thing is what it says it is‚Ää‚Äî‚Ääa Customer. Now it might be a `null` pretending to be a Customer.

This is chaos! A `null` result can now flow into unsuspecting code that‚Äôs meant to work with exactly one Customer. That code will blow up when it encounters the impostor, and we won‚Äôt even know where the problem started.

We‚Äôll get the dreaded [null reference exception](https://msdn.microsoft.com/en-us/library/system.nullreferenceexception%28v=vs.110%29.aspx), famous not only for it‚Äôs inability to tell us where it came from, but also sometimes it‚Äôs [inability to even tell us *what* was null](https://github.com/dotnet/coreclr/issues/25)! (If avoiding this isn‚Äôt a good argument for Functional Programming, what is?)

So again, the developer, not the compiler, must remember this and account for it:

## Total Functions (Honestly this time)

![Total Functions](/img/total-functions-3.jpeg)

The signature for `Where` looks like:

```C#
public static IEnumerable<Customer> Where(...)
```

This solves the issues outlined above:

* Unlike `Single`, it will return a value for every input. (It‚Äôs a total function)
* Unlike `SingleOrDefault`, the signature tells us everything it could return. It‚Äôs honest!

This time we can‚Äôt just pretend the result is a single Customer like we could with `SingleOrDefault`. We can‚Äôt do:

This obviously won‚Äôt compile. Instead we need to get real and deal with the fact that the first line will return a *collection* of Customers.

## Conclusion

We‚Äôve removed the source of exceptions and nulls by making sure we use total functions, but there are still at least a couple of things that probably stand out:

* The signature of `Where` is almost too broad, whilst we know it should only return at most one Customer, the signature suggests there could be any number of Customers. I‚Äôll deal with that in the next post.
* If we do this everywhere that there might have been a `null` before, won‚Äôt we have to write a tonne of boilerplate code to deal with checking whether the returned collection is empty or not? That‚Äôs going to be just as much work as checking for exceptions/nulls was, except now we‚Äôre being forced to do it every time.

On the latter point I‚Äôve kind of jumped the gun a bit by showing how `SelectMany` allows us to skip the boilerplate. I think it‚Äôs worth another post looking into how that works though. It might just be the key to the real essence and power of monads.
